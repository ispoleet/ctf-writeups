#!/usr/bin/env python2
# --------------------------------------------------------------------------------------------------
# Teaser CONFidence CTF 2019 - watchmen (RE 264)
# --------------------------------------------------------------------------------------------------
import struct
import ctypes
import capstone



# --------------------------------------------------------------------------------------------------
# code segments to decrypt (we can infer them from key_table addresses)
#
code1 = [                                       # starts at 0x401C20
    0x0F, 0x0B, 0x31, 0xCB, 0x9B, 0x2A, 0x8E, 0x57, 0xD1, 0xAA, 0x6C, 0x72, 0x15, 0xFE, 0x57,
    0xD1, 0xA6, 0x7C, 0x12, 0x58, 0xFE, 0x33, 0xEE, 0x0F, 0x0B, 0xA6, 0x93, 0xD1, 0x96, 0x1D,
    0x46, 0x0F, 0x60, 0x86, 0x93, 0xC1, 0xA6, 0x93, 0xD1, 0xAA, 0x1D, 0x46, 0x0F, 0x60, 0x96,
    0x93, 0xC1, 0xA6, 0x93, 0xD1, 0x96, 0x1D, 0x46, 0xED, 0x4B, 0x95, 0x3C, 0x96, 0x06, 0x9B,
    0xD1, 0xA6, 0x7B, 0x0F, 0x0B, 0xA6, 0x5D, 0xA0, 0x44, 0x0F, 0x0B, 0x52, 0x8E, 0xC3, 0xC1,
    0x5B, 0x0F, 0x0B, 0x31, 0x9B, 0x2A, 0x8E, 0x93, 0xD1, 0x96, 0x0F, 0x60, 0x9E, 0x96, 0xD1,
    0xA3, 0x57, 0xD1, 0xA2, 0x7C, 0x12, 0x58, 0xFE, 0x33, 0xE0, 0x0F, 0x0B, 0xA2, 0x93, 0xD1,
    0x96, 0x1D, 0x46, 0x0F, 0x60, 0x9E, 0x5E, 0x2E, 0x9A, 0x95, 0x55, 0x93, 0xD1, 0xA2, 0x91,
    0xC6, 0x9D, 0x93, 0xD1, 0x96, 0x1D, 0x46, 0x0F, 0x60, 0x9E, 0x0F, 0x60, 0xDE, 0x5D, 0x36,
    0x9A, 0x15, 0x55, 0x93, 0xC1, 0xA2, 0x93, 0xD1, 0x96, 0x1D, 0x46, 0x95, 0x4C, 0x96, 0x06,
    0x9B, 0xD1, 0xA2, 0x7B, 0x0F, 0x0B, 0xA2, 0x5E, 0xA0, 0x52, 0x0F, 0x0B, 0x96, 0x9B, 0x56,
    0x7F, 0x0F, 0x60, 0x9E, 0x5E, 0x2E, 0x9A, 0x95, 0x54, 0x0F, 0x60, 0x59, 0x81, 0x5D, 0x36,
    0x9A, 0x15, 0x54, 0x93, 0xD1, 0x96, 0x9B, 0x56, 0x7F, 0x96, 0x06, 0x8E, 0x55, 0x5B, 0x0F,
    0x0B, 0x31, 0x9D, 0x2A, 0xDE, 0x7C, 0x12, 0x58, 0x57, 0xD1, 0xAE, 0x30, 0x72, 0x15, 0xFE,
    0x57, 0xD1, 0xA2, 0x7C, 0x12, 0x58, 0xFE, 0x33, 0xED, 0x0F, 0x0B, 0xA2, 0x93, 0xC1, 0xA2,
    0x95, 0x82, 0x19, 0x10, 0x13, 0x59, 0xFF, 0x93, 0xC1, 0xA2, 0x93, 0xD1, 0x96, 0x1D, 0x46,
    0x0F, 0x60, 0x9E, 0x91, 0x89, 0x52, 0x7D, 0x13, 0x59, 0x93, 0xC1, 0xA2, 0x1D, 0x4C, 0x96,
    0x14, 0x9B, 0xD1, 0xA2, 0x7B, 0x0F, 0x0B, 0xA2, 0x5D, 0xA0, 0x45, 0x0F, 0x0B, 0xA6, 0x7C,
    0x12, 0x58, 0xFE, 0x33, 0xAB, 0x0F, 0x0B, 0xA6, 0x85, 0x5D, 0x2C, 0x83, 0x1D, 0x46, 0x9B,
    0x36, 0x7F, 0xF5, 0x46, 0x93, 0x92, 0x19, 0x10, 0x13, 0x59, 0xFF, 0x96, 0xD1, 0xAF, 0x93,
    0xC1, 0xA6, 0x93, 0xD1, 0xAE, 0x1D, 0x46, 0x0F, 0x60, 0x9E, 0x0F, 0x60, 0xDE, 0x9B, 0x36,
    0x7F, 0x95, 0x55, 0x93, 0xD1, 0xA6, 0x85, 0x5D, 0x2C, 0x83, 0x1D, 0x46, 0x9B, 0x36, 0x7F,
    0xF5, 0x46, 0x95, 0x54, 0x93, 0x92, 0x11, 0x10, 0x13, 0x59, 0xFF, 0x95, 0x92, 0x09, 0x10,
    0x13, 0x59, 0xFF, 0x93, 0xC1, 0xA6, 0x93, 0xD1, 0xAE, 0x1D, 0x46, 0x0F, 0x60, 0x9E, 0x0F,
    0x60, 0xDE, 0x9B, 0x36, 0x7F, 0x95, 0x54, 0x0F, 0x60, 0x59, 0x8D, 0x95, 0x92, 0x09, 0x10,
    0x13, 0x59, 0xFF, 0x9B, 0xD1, 0xA6, 0x7B, 0x0F, 0x0B, 0xA6, 0x93, 0xD1, 0xAE, 0x1D, 0x46,
    0x0F, 0x60, 0x9E, 0x9A, 0x56, 0xA9, 0x90, 0x0F, 0x0B, 0xAA, 0x7C, 0x12, 0x58, 0xFE, 0x33,
    0xF6, 0x0F, 0x0B, 0xAA, 0x93, 0x92, 0x19, 0x10, 0x13, 0x59, 0xFF, 0x93, 0xC9, 0xAA, 0x93,
    0xC1, 0x96, 0x1D, 0x4C, 0x0F, 0x60, 0x1A, 0x77, 0xC6, 0x59, 0xFF, 0x03, 0x96, 0x14, 0x9B,
    0xD1, 0xAA, 0x7B, 0x0F, 0x0B, 0xAA, 0x5D, 0xA0, 0x3C, 0x0F, 0x0B, 0x5B, 0x0F, 0x0B, 0x31,
    0x9B, 0x2A, 0x9A, 0x93, 0xD1, 0x96, 0x95, 0x12, 0x7A, 0x36, 0xE6, 0xA0, 0x7D, 0x13, 0x0F,
    0x0B, 0x96, 0x95, 0x12, 0x7A, 0x36, 0xA5, 0xA0, 0x7D, 0x13, 0x0F, 0x0B, 0x96, 0x95, 0x12,
    0x7A, 0x36, 0x3A, 0xA0, 0x7D, 0x13, 0x0F, 0x0B, 0x5B, 0x0F, 0x0B, 0x31, 0x9B, 0x2A, 0x8A,
    0x57, 0xD1, 0xA2, 0x7C, 0x12, 0x58, 0xFE, 0x33, 0x07, 0x0F, 0x0B, 0x96, 0x95, 0x12, 0x7A,
    0x36, 0x5A, 0x9F, 0x7D, 0x13, 0x0F, 0x0B, 0xA2, 0x7B, 0x0F, 0x0B, 0xA2, 0x6D, 0xA0, 0x2B,
    0x0F, 0x0B, 0x5B, 0x0F, 0x0B, 0x31, 0x9B, 0x2A, 0x76, 0x57, 0xD1, 0xAA, 0xD4, 0x72, 0x15,
    0xFE, 0x93, 0xD1, 0x96, 0x95, 0x12, 0x7A, 0x36, 0x55, 0x9F, 0x7D, 0x13, 0x0F, 0x0B, 0x7A,
    0x74, 0xF2, 0x58, 0xFE, 0x02, 0x93, 0xD1, 0x96, 0x95, 0xD2, 0x7A, 0x78, 0x93, 0xD1, 0xAA,
    0x95, 0x12, 0x7A, 0x36, 0x1C, 0x4F, 0x79, 0x12, 0x0F, 0x0B, 0x0F, 0x82, 0xDE, 0x55, 0x5B,
    0x0F, 0x0B, 0x31, 0x9B, 0x2A, 0x56, 0x57, 0x12, 0x7A, 0xB0, 0x72, 0x15, 0xFE, 0x36, 0x4D,
    0x4F, 0x79, 0x12, 0x0F, 0x0B, 0xC8, 0x95, 0xD2, 0x7A, 0x78, 0x57, 0x12, 0x7A, 0x4D, 0x71,
    0x15, 0xFE, 0x36, 0x68, 0x4F, 0x79, 0x12, 0x0F, 0x0B, 0xCD, 0x39, 0x12, 0x95, 0x12, 0x7A,
    0x36, 0x2D, 0x4F, 0x79, 0x12, 0x0F, 0x0B, 0xC8, 0x95, 0x12, 0x7A, 0x36, 0x8C, 0x9F, 0x7D,
    0x13, 0x0F, 0x0B, 0xA7, 0x9E, 0x99, 0xA7, 0x7C, 0xAA, 0x08, 0x0F, 0x0B, 0x7A, 0x48, 0x71,
    0x15, 0xFE, 0x36, 0x8D, 0x4F, 0x79, 0x12, 0x0F, 0x0B, 0x0F, 0x0B, 0x7A, 0xFC, 0x71, 0x15,
    0xFE, 0x36, 0x9B, 0x4F, 0x79, 0x12, 0x0F, 0x0B, 0x9E, 0x7C, 0x12, 0x55, 0x5B,

    # add some padding
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]

code2 = [                                       # starts at 0x436E3C
    0x0F, 0x0B, 0xBA, 0xAB, 0xCF, 0x58, 0x90, 0x90,
    0x0F, 0x0B, 0xBE, 0xAB, 0xCF, 0x58, 0x90, 0x90,

    # add some padding
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]

code3 = [                                       # starts at 0x436E5C
    0x0F, 0x0B, 0xCA, 0xAB, 0xCF, 0x58, 0x90, 0x90,

    # add some padding
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]

code4 = [                                       # starts at 0x436E84
    0x0F, 0x0B, 0xDE, 0xAB, 0xCF, 0x58, 0x90, 0x90,

    # add some padding
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]



# --------------------------------------------------------------------------------------------------
# global variables
#
key_state  = (0, 0, [])
last_state = (0, 0, [])
glo_a = 0
glo_b = 0



# --------------------------------------------------------------------------------------------------
# based on address, select the proper code chunk and return the bytes at the right offset
#
def read_mem(address, size):
    global code1, code2, code3, code4

    if   0x401C20 <= address and address+size <= 0x401C20 + len(code1):
        return code1[address-0x401C20 : address-0x401C20 + size]

    elif 0x436E3C <= address and address+size <= 0x436E3C + len(code2):
        return code2[address-0x436E3C : address-0x436E3C + size]

    elif 0x436E5C <= address and address+size <= 0x436E5C + len(code3):
        return code3[address-0x436E5C : address-0x436E5C + size]

    elif 0x436E84 <= address and address+size <= 0x436E84 + len(code4):
        return code4[address-0x436E84 : address-0x436E84 + size]
    
    else:
        raise Exception('Invalid address 0x%x' % address)



# --------------------------------------------------------------------------------------------------
# based on address, select the proper code chunk and write data at the right offset
#
def write_mem(address, size, data):
    global code1, code2, code3, code4

    if size != len(data):
        raise Exception('size != len(data)')

    if size < 1:
        return                             # if writing makes sense


    if   0x401C20 <= address and address+size <= 0x401C20 + len(code1):
        code1 = code1[:address-0x401C20] + data + code1[address-0x401C20 + size:]

    elif 0x436E3C <= address and address+size <= 0x436E3C + len(code2):
        code2 = code2[:address-0x436E3C] + data + code2[address-0x436E3C + size:]

    elif 0x436E5C <= address and address+size <= 0x436E5C + len(code3):
        code3 = code3[:address-0x436E5C] + data + code3[address-0x436E5C + size:]

    elif 0x436E84 <= address and address+size <= 0x436E84 + len(code4):
        code4 = code4[:address-0x436E84] + data + code4[address-0x436E84 + size:]

    else:
        raise Exception('Invalid address 0x%x' % address)



# --------------------------------------------------------------------------------------------------
# based on illegal instruction address find the appropriate key
#
def key_lookup(address):
    key_table = [
        (0x401C20, 0x8955), (0x401C37, 0x558B), (0x401C5F, 0x7D83), (0x401C65, 0x8390),
        (0x401C6C, 0x8955), (0x401C84, 0x558B), (0x401CBA, 0x7D83), (0x401CC0, 0x458B),
        (0x401CE2, 0x8955), (0x401CFB, 0x458B), (0x401D24, 0x7D83), (0x401D2A, 0x45C7),
        (0x401D33, 0x458B), (0x401D9E, 0x558B), (0x401DAD, 0x45C7), (0x401DB6, 0x458B),
        (0x401DD6, 0x7D83), (0x401DDC, 0xC990), (0x401DDF, 0x8955), (0x401DF0, 0x458B),
        (0x401DFB, 0x458B), (0x401E06, 0xC990), (0x401E09, 0x8955), (0x401E18, 0x458B),
        (0x401E23, 0x4583), (0x401E27, 0x7D83), (0x401E2D, 0xC990), (0x401E30, 0x8955),
        (0x401E48, 0x44C7), (0x401E62, 0xC085), (0x401E69, 0x8955), (0x401E7B, 0x458D),
        (0x401E8E, 0xA8A1), (0x401E9B, 0x458D), (0x401EA6, 0x4588), (0x401EAF, 0x04C7),
        (0x401EBB, 0x0CEB), (0x401EBD, 0x04C7), (0x401EC9, 0x00B8), 

        (0x436E3C, 0x25FF), 

        (0x436E44, 0x25FF),

        (0x436E5C, 0x25FF), 

        (0x436E84, 0x25FF)
    ]

    # assume address always exists, otherwise well get an IndexError exception
    return filter(lambda x: x[0] == address, key_table)[0][1]



# --------------------------------------------------------------------------------------------------
# The actual code decryption algorithm (quite simple, isn't it?)
#
def decrypt(code, size):
    key = [0x0F, 0x0B, 0x4F, 0x3E, 0x89, 0xAC, 0xFF, 0x81,
           0xBA, 0x7E, 0xEC, 0xCC, 0x66, 0x29, 0xEE, 0x10]

    out = [0]*size

    for i in range(size):
        out[i] = (~(code[i] - key[i]) + 1 + key[i]) & 0xff

    return out



# --------------------------------------------------------------------------------------------------
# stage 2 of decryption algorithm
#
def decrypt_stage_2(address):
    global key_state, last_state, glo_a, glo_b    

    # read 16 bytes and decrypt them
    code = read_mem(address, 16)
    decr_code = decrypt(code, 16)


    code = decr_code
    code_str = ''.join(['%c' % c for c in code])

    # -------------------------------------------------------------------------
    # disassemble the instruction
    # -------------------------------------------------------------------------
    md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
    sz = -1

    for i in md.disasm(code_str, address):
        print "0x%x:     %s\t%s" % (i.address, i.mnemonic, i.op_str)
        sz, opcode =  i.size, i.mnemonic
        break

    # this insturction disassembled incorrectly by capstone. Fix it       
    if code_str[:5] == '\xa1\xa8\xd1\x43\x00':
        size, opcode = 5, "mov     eax, ds:_iob"
        print "Correction:", opcode


    if sz == -1:
        raise Exception('Disassembly at 0x%x failed' % address)


    # update last state
    if glo_a != 0: glo_b = 0

    decr_code2 = decrypt(decr_code[sz:16], 16-sz)
    data = read_mem(address, 16)

    write_mem(address, 16-sz, decr_code2)

    last_state = (address, 16, data)

    return sz, opcode



# --------------------------------------------------------------------------------------------------
# illegal instruction exception handler
#
def illegal_instr(address):
    global key_state, last_state, glo_a, glo_b

    write_mem(*last_state)
    write_mem(*key_state)

    glo_b = 1

    key = key_lookup(address)
    key_list = [key & 0xff, (key & 0xff00) >> 8]
    key_state = (address, 2, key_list)

    decr_code = decrypt(key_list, 2)
    data = read_mem(address, 2)    

    # replace the first two bytes
    write_mem(address, 2, decr_code)
    key_state = (address, 2, data)

    sz, opcode = decrypt_stage_2(address)

    return sz, opcode



# --------------------------------------------------------------------------------------------------
# single step exception handler (Trap Flag is set)
#
def single_step(address):
    global key_state, last_state, glo_a, glo_b

    write_mem(*last_state)
    

    if address < key_state[0] or address >= key_state[0] + key_state[1]:
        write_mem(*key_state)

    else:
        write_mem(*key_state)

        key = key_lookup(key_state[0])
        key_list = [key & 0xff, (key & 0xff00) >> 8]
        key_state = (key_state[0]+1, 1, key_list[1:])

        decr_code = decrypt(key_list[1:], 1)
        data = read_mem(address, 1)

        write_mem(address, 1, decr_code)
        key_state = (address, 1, data)


    if glo_b != 0:
        sz, opcode = decrypt_stage_2(address)
        return sz, opcode

    else:
        return 0, ''



# --------------------------------------------------------------------------------------------------
# The main code decryption routine
#
def decrypt_code(entry, end):
    print '; --------------------------------------------------------------'    

    address = entry


    sz, opcode = illegal_instr(address)
    address   += sz

    while address < end:
        sz, opcode = single_step(address)

        # if you hit an undefined instruction, run the illegal instruction exception handler
        if opcode == "ud2":
            sz, opcode = illegal_instr(address)

        address += sz



# --------------------------------------------------------------------------------------------------
# main()
#
if __name__ == "__main__":
    print 'Watchmen code decryptor started.'

    # decrypt all code chunks
    decrypt_code(0x401C20, 0x401ED0)
    decrypt_code(0x436E3C, 0x436E42)
    decrypt_code(0x436E44, 0x436E4A)
    decrypt_code(0x436E5C, 0x436E62)
    decrypt_code(0x436E84, 0x436E8A)


# --------------------------------------------------------------------------------------------------
'''
C:\Users\ispo\watchmen> C:\Python27\python.exe watchmen_decrypt.py
Watchmen code decryptor started.
; --------------------------------------------------------------
0x401c20:     push      rbp
0x401c21:     mov       ebp, esp
0x401c23:     push      rbx
0x401c24:     sub       esp, 0x10
0x401c27:     mov       dword ptr [rbp - 0xc], 0x43a010
0x401c2e:     mov       dword ptr [rbp - 8], 0
0x401c35:     jmp       0x401c5f
[..... TRUNCATED FOR BREVITY .....]
0x401ea1:     call      0x401e30
0x401ea6:     ud2
0x401ea6:     mov       byte ptr [rbp - 9], al
0x401ea9:     cmp       byte ptr [rbp - 9], 0
0x401ead:     je        0x401ebd
0x401eaf:     ud2
0x401eaf:     mov       dword ptr [rsp], 0x43a134
0x401eb6:     call      0x436e44
0x401ebb:     ud2
0x401ebb:     jmp       0x401ec9
0x401ebd:     ud2
0x401ebd:     mov       dword ptr [rsp], 0x43a180
0x401ec4:     call      0x436e44
0x401ec9:     ud2
0x401ec9:     mov       eax, 0
0x401ece:     leave
0x401ecf:     ret
; --------------------------------------------------------------
0x436e3c:     jmp       qword ptr [rip + 0x43d1e4]
; --------------------------------------------------------------
0x436e44:     jmp       qword ptr [rip + 0x43d1e0]
; --------------------------------------------------------------
0x436e5c:     jmp       qword ptr [rip + 0x43d1d4]
; --------------------------------------------------------------
0x436e84:     jmp       qword ptr [rip + 0x43d1c0]
'''
# --------------------------------------------------------------------------------------------------
