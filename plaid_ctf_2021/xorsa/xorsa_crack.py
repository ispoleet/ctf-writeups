#!/usr/bin/env python3
# ----------------------------------------------------------------------------------------
# Plaid CTF 2021 - xorsa (Crypto 100)
# ----------------------------------------------------------------------------------------
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Util import number


x = 16158503035655503426113161923582139215996816729841729510388257123879913978158886398099119284865182008994209960822918533986492024494600106348146394391522057566608094710459034761239411826561975763233251722937911293380163746384471886598967490683174505277425790076708816190844068727460135370229854070720638780344789626637927699732624476246512446229279134683464388038627051524453190148083707025054101132463059634405171130015990728153311556498299145863647112326468089494225289395728401221863674961839497514512905495012562702779156196970731085339939466059770413224786385677222902726546438487688076765303358036256878804074494


# ----------------------------------------------------------------------------------------
# Checks if a new set of bits for p, q is valid or not
def check_bits(p_bit, q_bit, p_num, q_num, n_b):
    assert(len(p_num) == len(q_num))
    
    p = int('0b' + (p_bit) + p_num, 2)
    q = int('0b' + (q_bit) + q_num, 2)

    # Although the p*q generates len(p)+len(q) bits for n, we only check the len(p)
    # lsbits of n, as the len(p)+1 bit may be different from the target n.
    n = bin(p * q)[2:]
    n = n[len(n) - (len(p_num)+1):]

    return n_b.endswith(n)


# ----------------------------------------------------------------------------------------
def factorize_n(x, n):
    print('[+] Factorizing n:', n)
    print('[+] Using x = p ^ q:', x)

    x_b = bin(x)[2:]                # Drop the '0b' part.
    n_b = bin(n)[2:]
    
    print('[+] Bit length of x:', len(x_b))
    x_b = '0' + x_b                 # Add the leading 0 in x (x_b is 2047 bits).

    # Base case. We know that:
    #   p_0 ^ q_0 = 0, and
    #   p_0 * q_0 = n_0 = 1 mod 2^0
    #
    #   Then: p_0 = 1 and q_0 = 1
    queue = [(1, '1', '1')]

    # Iterative case. 10 lsb of n = 1100110111
    # 
    # For the 2nd lsbit:
    #   p_1 ^ q_1 = 1
    #   p_[0:1] ^ q_[0:1] = n_[0:2] mod 2^2 = 0111
    #
    #   We have 2 cases:
    #       1. p = 01, q = 11 => p*q = 3 = 11b == n
    #       2. p = 11, q = 01 => p*q = 3 = 11b == n
    #
    # We have 2 solutions here, which are symmetric. We keep both in queue.
    #
    # Note that we only check the len(p) lsbits of n. Here if we check the
    # len(p) + len(q) = 4 lsbits we get 0111 != 0011 so there is no solution.
    #
    # For the 3rd lsbit: 
    #   p_2 ^ q_2 = 1
    #   p_[0:2] ^ q_[0:2] = n_[0:3] mod 2^3
    #
    #   We have 2 cases:
    #       1. p = 101, q = 011 => p*q = 15 = 1111b = n (VALID)
    #       2. p = 001, q = 111 => p*q = 7  = 0111b = n (VALID)
    #
    # For the 4th lsbit:
    #   p_3 ^ q_3 = 1
    #   p_[0:3] ^ q_[0:3] = n_[0:4] mod 2^4 
    #
    #   We have 2 cases:
    #       1. p = 0001, q = 1111 => p*q = 15 = 1111b   != 0111n = n     (INVALID)
    #       2. p = 1001, q = 0111 => p*q = 63 = 111111b != 00110111b = n (INVALID)
    #
    #   Therefore, the p = 001, q = 111 gives no solution and therefore is discarded
    #
    #   Then we try the 2nd pair:
    #       1. p = 0101, q = 1011 => p*q = 55 = 110111b == n (VALID)
    #       2. p = 1101, q = 0011 => p*q = 39 = 10111b  == n (VALID)
    #
    # As you can see at each step we either have 0 or 2 valid solutions.
    final_solutions = []

    # We use a queue. Once we check all p,q pairs at length i, we move on length i+1.
    while queue:
        l, p_b, q_b = queue.pop(0)

        if l == 2048:
            final_solutions.append((p_b, q_b))
            continue

        # Get the i-th bit of x.
        x_bit = x_b[::-1][l]

        print('[+] i:%4d x_i:%s, p:%s, q:%s, queue_sz:%d' % (l, x_bit, p_b[:32], q_b[:32], len(queue)))

        if x_bit == '0':
            # p_i and q_i are equal.

            # Case #3: p_i = 0 and q_i = 0
            if check_bits('0', '0', p_b, q_b, n_b):
                queue.append((l+1, '0'+p_b, '0'+q_b))

            # Case #4: p_i = 1 and q_i = 1
            if check_bits('1', '1', p_b, q_b, n_b):
                queue.append((l+1, '1'+p_b, '1'+q_b))

        elif x_bit == '1':
            # p_i and q_i are different.

            # Case #1: p_i = 0 and q_i = 1
            if check_bits('1', '0', p_b, q_b, n_b):
                queue.append((l+1, '1'+p_b, '0'+q_b))

            # Case #2: p_i = 1 and q_i = 0
            if check_bits('0', '1', p_b, q_b, n_b):
                queue.append((l+1, '0'+p_b, '1'+q_b))


    print('[+] Done. %d possible solutions found' % len(final_solutions))

    # Check which of the solutions is valid.
    for p,q in final_solutions:
        p_b = int('0b' + p, 2)
        q_b = int('0b' + q, 2)
        n_b = bin(p_b * q_b)

        if int(n_b, 2) == n:
            print('[+] Solution found!')
            return int(p, 2), int(q, 2)

    raise Exception('Cannot find a solution')


# ----------------------------------------------------------------------------------------
def rsa_decrypt(cipher, n, e, p, q):
    d = number.inverse(e, (p - 1)*(q - 1))
    print('[+] Private exponent:', d)

    key = RSA.construct((n, e, d, p, q))
    rsa_cipher = PKCS1_OAEP.new(key)
    plain = rsa_cipher.decrypt(cipher)

    return plain


# ----------------------------------------------------------------------------------------
if __name__ == "__main__":
    print('[+] Plaid CTF 2021 xorsa crack started.')

    with open('dist/public.pem', 'r') as fp:
        key = RSA.importKey(fp.read())

    print('[+] Reading n:', key.n)
    print('[+] Reading e:', key.e)
    print('[+] Bit length of n:', key.n.bit_length())
    print('[+] x = p xor q:', bin(x)) 

    p, q = factorize_n(x, key.n)

    print('[+] p:', p)
    print('[+] q:', q)

    # Load flag (flag ** d mod n).
    with open('dist/flag.enc', 'rb') as fp:
        enc_flag = fp.read()

    flag = rsa_decrypt(enc_flag, key.n, key.e, p, q)

    print('[+] Decrypted flag:', flag)
    print('[+] Program finished. Bye bye :)')


# ----------------------------------------------------------------------------------------
'''
[+] Plaid CTF 2021 xorsa crack started.
[+] Reading n: 57290089902041633387177425789754819088787514833237764972462993....
[+] Reading e: 65537
[+] Bit length of n: 4096
[+] x = p xor q: 0b111111111111111111111111111111111111111111111111111111101111111....
[+] Factorizing n: 572900899020416333871774257897548190887875148332377649724629936....
[+] Using x = p ^ q: 1615850303565550342611316192358213921599681672984172951038825....
[+] Bit length of x: 2047
[+] i:   1 x_i:1, p:1, q:1, queue_sz:0
[+] i:   2 x_i:1, p:11, q:01, queue_sz:1
[+] i:   2 x_i:1, p:01, q:11, queue_sz:2
[+] i:   3 x_i:1, p:111, q:001, queue_sz:3
[+] i:   3 x_i:1, p:011, q:101, queue_sz:2
[+] i:   3 x_i:1, p:101, q:011, queue_sz:3
[+] i:   3 x_i:1, p:001, q:111, queue_sz:4
[+] i:   4 x_i:1, p:1011, q:0101, queue_sz:3
[+] i:   4 x_i:1, p:0011, q:1101, queue_sz:2
[+] i:   4 x_i:1, p:1101, q:0011, queue_sz:3
[+] i:   4 x_i:1, p:0101, q:1011, queue_sz:4
[+] i:   5 x_i:1, p:10011, q:01101, queue_sz:3
[+] i:   5 x_i:1, p:00011, q:11101, queue_sz:2
[+] i:   5 x_i:1, p:11101, q:00011, queue_sz:3
[+] i:   5 x_i:1, p:01101, q:10011, queue_sz:4
[+] i:   6 x_i:1, p:100011, q:011101, queue_sz:3
[+] i:   6 x_i:1, p:000011, q:111101, queue_sz:4
[+] i:   6 x_i:1, p:111101, q:000011, queue_sz:3
[+] i:   6 x_i:1, p:011101, q:100011, queue_sz:2
[+] i:   7 x_i:1, p:1100011, q:0011101, queue_sz:3
[+] i:   7 x_i:1, p:0100011, q:1011101, queue_sz:2
[+] i:   7 x_i:1, p:1011101, q:0100011, queue_sz:3
[+] i:   7 x_i:1, p:0011101, q:1100011, queue_sz:4
[+] i:   8 x_i:1, p:10100011, q:01011101, queue_sz:3
[+] i:   8 x_i:1, p:00100011, q:11011101, queue_sz:2
[+] i:   8 x_i:1, p:11011101, q:00100011, queue_sz:3
[+] i:   8 x_i:1, p:01011101, q:10100011, queue_sz:4
[+] i:   9 x_i:1, p:100100011, q:011011101, queue_sz:3
[+] i:   9 x_i:1, p:000100011, q:111011101, queue_sz:2
[+] i:   9 x_i:1, p:111011101, q:000100011, queue_sz:3
[+] i:   9 x_i:1, p:011011101, q:100100011, queue_sz:4
[+] i:  10 x_i:1, p:1000100011, q:0111011101, queue_sz:3
[+] i:  10 x_i:1, p:0000100011, q:1111011101, queue_sz:4
[.... TRUNCATED FOR BREVITY ....]
[+] i:2047 x_i:0, p:00101110000011110100100011011000, q:11010001111100001011011100100111, queue_sz:350
[+] i:2047 x_i:0, p:11101110101001100110001100010000, q:00010001010110011001110011101111, queue_sz:351
[+] i:2047 x_i:0, p:01101110101001100110001100010000, q:10010001010110011001110011101111, queue_sz:350
[+] i:2047 x_i:0, p:11101110101001100110001100010000, q:00010001010110011001110011101111, queue_sz:351
[+] i:2047 x_i:0, p:01101110101001100110001100010000, q:10010001010110011001110011101111, queue_sz:350
[+] i:2047 x_i:0, p:10011011011010111000010010000101, q:01100100100101000111101101111010, queue_sz:351
[+] i:2047 x_i:0, p:00011011011010111000010010000101, q:11100100100101000111101101111010, queue_sz:350
[+] i:2047 x_i:0, p:10011011011010111000010010000101, q:01100100100101000111101101111010, queue_sz:351
[+] i:2047 x_i:0, p:00011011011010111000010010000101, q:11100100100101000111101101111010, queue_sz:350
[+] Done. 352 possible solutions found
[+] Solution found!
[+] p: 28054539427494619618149689905596076429856984445645433669516156290418225421410517787779668517055290133852649936139827864804362688012118333884178242727752944519074048590360750318612378539438159662786353326373062884835264801371859099448845473624420663390433385862519105545532536453262415924316279385374822224406717473538131244397856571015984808737311810992683556365367226442459037956423012864505787939824387975762988816118609146663560957688289879555734075738210834196560874913737409142987175846607589921563622580505680695004314201238943582440280860553616004146782317383144868597295249895821620037478662736479377036405283
[+] q: 20420969679471891108678348706656014746583934953911779875638425062354608191587183527950669164730700934272964182495787953304429468689762991322834551415645126708376516740680832417842286228420321593951669261051536747972457884863137310884282408490497575698325423547287860485177580030001077220138986358776296171919687266364733033819652040824038462023264875486252347426522916763724808898841410387685709431644531618456599577633972666332007415430841589961044976519245509149515296930564608453957399860365835338361556249254149485870260959744131461233248546913266875137205814224895267413530734240509464368626036706116974009128413
[+] Private exponent: 535285619583077861182297403117299631060746552832519233459541778822864737303385391851361567543637694274158426416278967309378225150637136603668223579967789383575285393522992984933268738737938366152562016000970892035823128314957977417987218856389780697192383400194393662047124025788372395152963041419329633875978636073431501131016070793025404911244522559377889826487381996867378788897862816393399299337956703620565118956493138534622572797886471804211115839681647906937455306935147378415038950694541595495710238530775724879252762707128502090357511300183078956084673341887240193885108452549401945480063407186847604120674082710523048815559298616377544784961049889771483942552805958150794797092304383110395391527869549917583930097957976487107207035946451900625350972043498357387383603356165930932466566348547216590938141201164371892206793247489070643866760277199081050203926377236184497289377231862359384181445180057706579505389840149356090999441273327395305897743017265998396266321082078333643288340478563759512586013751907147133200822246159111216504789138478607928704815594531332629277220201223351331173818489256394139408317767849633037903296139575550272170982395091606877422101093706446971115551923917936202881345036430929492339972382961
[+] Decrypted flag: b'PCTF{who_needs_xor_when_you_can_add_and_subtract}'
[+] Program finished. Bye bye :)
'''
# ----------------------------------------------------------------------------------------

